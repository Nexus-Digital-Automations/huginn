# frozen_string_literal: true

require 'open3'
require 'json'
require 'tempfile'
require 'pathname'

module SecurityValidation
  # VulnerabilityScanner performs automated security vulnerability scanning using
  # brakeman for static analysis and bundler-audit for dependency vulnerability detection.
  #
  # This scanner integrates with the quality gates system to identify security vulnerabilities
  # with zero tolerance for high/critical severity issues in production deployments.
  #
  # Features:
  # - Brakeman static security analysis for Ruby/Rails applications
  # - Bundler-audit for known vulnerability detection in dependencies
  # - Comprehensive vulnerability severity classification
  # - Integration with quality gates and CI/CD pipelines
  # - Detailed security reporting with actionable recommendations
  # - Support for security baseline management and exemption handling
  #
  # Severity Levels:
  # - CRITICAL: Immediate security risk requiring emergency patching
  # - HIGH: Significant security risk requiring urgent attention
  # - MEDIUM: Moderate security risk for regular patching cycle
  # - LOW: Minor security concerns for next maintenance window
  # - INFO: Security best practices recommendations
  class VulnerabilityScanner
    include Utils

    attr_reader :project_root, :scan_results, :logger, :config

    # Vulnerability severity mapping for risk assessment
    SEVERITY_LEVELS = {
      critical: { priority: 1, max_allowed: 0, description: 'Critical security vulnerability requiring immediate attention' },
      high: { priority: 2, max_allowed: 0, description: 'High severity security issue requiring urgent remediation' },
      medium: { priority: 3, max_allowed: 5, description: 'Medium severity security concern' },
      low: { priority: 4, max_allowed: 10, description: 'Low severity security advisory' },
      info: { priority: 5, max_allowed: 50, description: 'Informational security recommendation' }
    }.freeze

    # Security tools configuration and paths
    SECURITY_TOOLS = {
      brakeman: {
        command: 'brakeman',
        install_command: 'gem install brakeman',
        description: 'Static security analysis for Ruby applications'
      },
      bundler_audit: {
        command: 'bundle-audit',
        install_command: 'gem install bundler-audit',
        description: 'Known vulnerability scanner for Ruby dependencies'
      }
    }.freeze

    def initialize(project_root = Rails.root, config = {})
      @project_root = Pathname.new(project_root)
      @config = load_security_config.merge(config)
      @scan_results = {}
      @logger = setup_security_logger
      
      log_operation_start('VulnerabilityScanner initialized', {
        project_root: @project_root.to_s,
        config_keys: @config.keys
      })
    end

    # Perform comprehensive vulnerability scanning across all security tools
    # @return [ScanResult] Comprehensive vulnerability scan results
    def scan_all_vulnerabilities
      log_operation_start('Starting comprehensive vulnerability scan')
      start_time = Time.current
      
      ensure_security_tools_available
      
      scan_results = {
        brakeman: perform_brakeman_scan,
        bundler_audit: perform_bundler_audit_scan,
        custom_checks: perform_custom_security_checks
      }
      
      combined_result = combine_scan_results(scan_results)
      log_operation_completion('Comprehensive vulnerability scan', start_time, combined_result)
      
      combined_result
    end

    # Perform static security analysis using Brakeman
    # @return [ScanResult] Brakeman security analysis results
    def perform_brakeman_scan
      log_operation_step('Running Brakeman static security analysis')
      start_time = Time.current
      
      begin
        # Configure Brakeman scan options
        brakeman_options = build_brakeman_options
        cmd = "cd #{project_root} && brakeman #{brakeman_options}"
        
        stdout, stderr, status = Open3.capture3(cmd)
        
        if status.success?
          brakeman_results = JSON.parse(stdout)
          scan_result = parse_brakeman_results(brakeman_results)
          
          log_security_scan_summary('Brakeman', scan_result)
          scan_result
        else
          error_result = create_scan_error_result('Brakeman', "Scan failed: #{stderr}")
          log_security_error('Brakeman', error_result.errors.first)
          error_result
        end
        
      rescue JSON::ParserError => e
        error_result = create_scan_error_result('Brakeman', "Failed to parse results: #{e.message}")
        log_security_error('Brakeman', error_result.errors.first)
        error_result
      rescue StandardError => e
        error_result = create_scan_error_result('Brakeman', "Unexpected error: #{e.message}")
        log_security_error('Brakeman', error_result.errors.first)
        error_result
      end
    end

    # Perform dependency vulnerability scanning using bundler-audit
    # @return [ScanResult] Bundler-audit dependency vulnerability results
    def perform_bundler_audit_scan
      log_operation_step('Running bundler-audit dependency vulnerability scan')
      start_time = Time.current
      
      begin
        # Update vulnerability database first
        update_cmd = "cd #{project_root} && bundle-audit update"
        Open3.capture3(update_cmd)
        
        # Run vulnerability scan
        scan_cmd = "cd #{project_root} && bundle-audit check --format json"
        stdout, stderr, status = Open3.capture3(scan_cmd)
        
        if status.success? || !stdout.strip.empty?
          # bundler-audit returns non-zero exit code when vulnerabilities found
          bundler_results = stdout.strip.empty? ? { advisories: [] } : JSON.parse(stdout)
          scan_result = parse_bundler_audit_results(bundler_results)
          
          log_security_scan_summary('Bundler-Audit', scan_result)
          scan_result
        else
          error_result = create_scan_error_result('Bundler-Audit', "Scan failed: #{stderr}")
          log_security_error('Bundler-Audit', error_result.errors.first)
          error_result
        end
        
      rescue JSON::ParserError => e
        # Handle case where bundler-audit output is not JSON
        if stdout.include?('No vulnerabilities found')
          create_clean_scan_result('Bundler-Audit')
        else
          error_result = create_scan_error_result('Bundler-Audit', "Failed to parse results: #{e.message}")
          log_security_error('Bundler-Audit', error_result.errors.first)
          error_result
        end
      rescue StandardError => e
        error_result = create_scan_error_result('Bundler-Audit', "Unexpected error: #{e.message}")
        log_security_error('Bundler-Audit', error_result.errors.first)
        error_result
      end
    end

    # Perform custom security checks specific to Huginn
    # @return [ScanResult] Custom security validation results
    def perform_custom_security_checks
      log_operation_step('Running custom Huginn security checks')
      
      vulnerabilities = []
      warnings = []
      
      # Check for insecure configurations
      vulnerabilities.concat(check_insecure_devise_configuration)
      vulnerabilities.concat(check_insecure_database_configuration)
      vulnerabilities.concat(check_unsafe_agent_configurations)
      
      # Check for security best practices
      warnings.concat(check_security_headers_configuration)
      warnings.concat(check_csrf_protection_configuration)
      warnings.concat(check_session_security_configuration)
      
      ScanResult.new(
        passed: vulnerabilities.empty?,
        tool: 'CustomSecurityChecks',
        vulnerabilities: vulnerabilities,
        warnings: warnings,
        summary: {
          critical_count: vulnerabilities.count { |v| v[:severity] == 'critical' },
          high_count: vulnerabilities.count { |v| v[:severity] == 'high' },
          medium_count: vulnerabilities.count { |v| v[:severity] == 'medium' },
          low_count: vulnerabilities.count { |v| v[:severity] == 'low' }
        }
      )
    end

    # Generate comprehensive security report
    # @param scan_results [ScanResult] Scan results to report on
    # @return [Hash] Detailed security report with recommendations
    def generate_security_report(scan_results = nil)
      scan_results ||= scan_all_vulnerabilities
      
      log_operation_start('Generating comprehensive security report')
      
      report = {
        scan_metadata: {
          timestamp: Time.current.iso8601,
          project_root: project_root.to_s,
          scanner_version: '1.0.0',
          scan_duration: calculate_scan_duration(scan_results)
        },
        
        vulnerability_summary: generate_vulnerability_summary(scan_results),
        
        security_status: {
          overall_risk_level: calculate_overall_risk_level(scan_results),
          compliance_status: assess_security_compliance(scan_results),
          quality_gate_status: evaluate_quality_gates(scan_results)
        },
        
        detailed_findings: generate_detailed_findings(scan_results),
        
        remediation_plan: generate_remediation_plan(scan_results),
        
        security_metrics: calculate_security_metrics(scan_results),
        
        recommendations: generate_security_recommendations(scan_results)
      }
      
      # Save report to development/reports directory
      save_security_report(report)
      
      log_operation_completion('Security report generation', Time.current - 1.second, scan_results)
      report
    end

    # Validate security compliance against established benchmarks
    # @param scan_results [ScanResult] Results to validate against compliance standards
    # @return [Hash] Compliance validation results
    def validate_security_compliance(scan_results)
      log_operation_step('Validating security compliance standards')
      
      compliance_checks = {
        owasp_top_10: validate_owasp_compliance(scan_results),
        rails_security_guide: validate_rails_security_compliance(scan_results),
        huginn_security_standards: validate_huginn_security_compliance(scan_results),
        production_readiness: validate_production_security_readiness(scan_results)
      }
      
      overall_compliance = compliance_checks.all? { |_, result| result[:compliant] }
      
      {
        compliant: overall_compliance,
        compliance_score: calculate_compliance_score(compliance_checks),
        detailed_results: compliance_checks,
        non_compliant_areas: compliance_checks.reject { |_, result| result[:compliant] }.keys,
        recommendations: generate_compliance_recommendations(compliance_checks)
      }
    end

    private

    # Set up security-specific logger with structured output
    def setup_security_logger
      logger = Logger.new($stdout)
      logger.level = Logger::INFO
      logger.formatter = proc do |severity, datetime, progname, msg|
        "[#{datetime.strftime('%Y-%m-%d %H:%M:%S')}] [SecurityValidation] #{severity}: #{msg}\n"
      end
      logger
    end

    # Load security configuration from config files
    def load_security_config
      config_file = project_root.join('config', 'security_validation.yml')
      if config_file.exist?
        YAML.safe_load(config_file.read, symbolize_names: true) || {}
      else
        default_security_config
      end
    end

    # Default security configuration
    def default_security_config
      {
        severity_thresholds: SEVERITY_LEVELS,
        brakeman: {
          confidence_level: 2,
          format: 'json',
          quiet: true,
          no_progress: true
        },
        bundler_audit: {
          update_on_scan: true,
          format: 'json'
        },
        quality_gates: {
          fail_on_critical: true,
          fail_on_high: true,
          max_medium_vulnerabilities: 5,
          max_low_vulnerabilities: 10
        }
      }
    end

    # Ensure required security tools are available
    def ensure_security_tools_available
      missing_tools = []
      
      SECURITY_TOOLS.each do |tool_name, tool_config|
        unless command_available?(tool_config[:command])
          missing_tools << tool_name
          log_security_warning("Missing security tool: #{tool_name} (#{tool_config[:description]})")
        end
      end
      
      unless missing_tools.empty?
        error_message = "Missing required security tools: #{missing_tools.join(', ')}"
        log_security_error('ToolAvailability', error_message)
        raise SecurityValidationError, error_message
      end
    end

    # Check if a command is available in the system PATH
    def command_available?(command)
      system("which #{command} > /dev/null 2>&1")
    end

    # Build Brakeman command line options
    def build_brakeman_options
      options = []
      options << '--format json'
      options << '--confidence-level 2'
      options << '--quiet'
      options << '--no-progress'
      
      # Add ignore file if it exists
      ignore_file = project_root.join('.brakeman.ignore')
      options << "--ignore-file #{ignore_file}" if ignore_file.exist?
      
      options.join(' ')
    end

    # Parse Brakeman JSON results into structured format
    def parse_brakeman_results(brakeman_data)
      vulnerabilities = []
      
      if brakeman_data['warnings']
        brakeman_data['warnings'].each do |warning|
          vulnerabilities << {
            tool: 'brakeman',
            type: warning['warning_type'],
            severity: map_brakeman_severity(warning['confidence']),
            message: warning['message'],
            file: warning['file'],
            line: warning['line'],
            code: warning['code'],
            fingerprint: warning['fingerprint'],
            check_name: warning['check_name'],
            remediation_advice: generate_brakeman_remediation(warning)
          }
        end
      end
      
      ScanResult.new(
        passed: vulnerabilities.empty?,
        tool: 'brakeman',
        vulnerabilities: vulnerabilities,
        warnings: [],
        summary: {
          total_files_scanned: brakeman_data['scan_info']&.dig('files') || 0,
          scan_duration: brakeman_data['scan_info']&.dig('duration') || 0,
          critical_count: vulnerabilities.count { |v| v[:severity] == 'critical' },
          high_count: vulnerabilities.count { |v| v[:severity] == 'high' },
          medium_count: vulnerabilities.count { |v| v[:severity] == 'medium' },
          low_count: vulnerabilities.count { |v| v[:severity] == 'low' }
        }
      )
    end

    # Parse bundler-audit results into structured format
    def parse_bundler_audit_results(bundler_data)
      vulnerabilities = []
      
      if bundler_data['advisories']
        bundler_data['advisories'].each do |advisory|
          vulnerabilities << {
            tool: 'bundler-audit',
            type: 'dependency_vulnerability',
            severity: map_bundler_audit_severity(advisory),
            message: advisory['title'],
            gem: advisory['gem'],
            version: advisory['version'],
            cve: advisory['cve'],
            osvdb: advisory['osvdb'],
            ghsa: advisory['ghsa'],
            url: advisory['url'],
            patched_versions: advisory['patched_versions'],
            unaffected_versions: advisory['unaffected_versions'],
            remediation_advice: generate_bundler_audit_remediation(advisory)
          }
        end
      end
      
      ScanResult.new(
        passed: vulnerabilities.empty?,
        tool: 'bundler-audit',
        vulnerabilities: vulnerabilities,
        warnings: [],
        summary: {
          critical_count: vulnerabilities.count { |v| v[:severity] == 'critical' },
          high_count: vulnerabilities.count { |v| v[:severity] == 'high' },
          medium_count: vulnerabilities.count { |v| v[:severity] == 'medium' },
          low_count: vulnerabilities.count { |v| v[:severity] == 'low' }
        }
      )
    end

    # Map Brakeman confidence levels to severity
    def map_brakeman_severity(confidence)
      case confidence
      when 0 then 'critical'  # High confidence
      when 1 then 'high'      # Medium confidence
      when 2 then 'medium'    # Low confidence
      else 'low'
      end
    end

    # Map bundler-audit advisory to severity based on available information
    def map_bundler_audit_severity(advisory)
      # Use CVE scoring or criticality indicators if available
      if advisory['criticality']
        case advisory['criticality'].downcase
        when 'critical' then 'critical'
        when 'high' then 'high'
        when 'medium' then 'medium'
        when 'low' then 'low'
        else 'medium'  # Default for unknown
        end
      elsif advisory['cve'] || advisory['ghsa']
        'high'  # CVE or GHSA identifiers typically indicate higher severity
      else
        'medium'  # Default severity for other advisories
      end
    end

    # Generate remediation advice for Brakeman findings
    def generate_brakeman_remediation(warning)
      case warning['warning_type']
      when 'SQL Injection'
        'Use parameterized queries or ActiveRecord methods to prevent SQL injection. Avoid string interpolation in SQL queries.'
      when 'Cross-Site Scripting'
        'Ensure proper output encoding using Rails helpers like html_safe or content_tag. Validate and sanitize user input.'
      when 'Mass Assignment'
        'Use strong parameters to explicitly allow only safe attributes. Review attr_accessible or params.require/permit usage.'
      when 'Command Injection'
        'Avoid system() calls with user input. Use safe alternatives or properly escape/validate input parameters.'
      when 'File Access'
        'Validate file paths to prevent directory traversal. Use Rails helpers for file operations when possible.'
      when 'Dangerous Send'
        'Avoid dynamic method calls with user input. Use explicit method calls or whitelist allowed methods.'
      else
        "Review the security implication of #{warning['warning_type']} and apply appropriate security controls."
      end
    end

    # Generate remediation advice for bundler-audit findings
    def generate_bundler_audit_remediation(advisory)
      advice = []
      
      if advisory['patched_versions'] && advisory['patched_versions'].any?
        advice << "Update #{advisory['gem']} to a patched version: #{advisory['patched_versions'].join(', ')}"
      end
      
      if advisory['unaffected_versions'] && advisory['unaffected_versions'].any?
        advice << "Alternative: Use an unaffected version: #{advisory['unaffected_versions'].join(', ')}"
      end
      
      advice << "Review the security advisory at #{advisory['url']}" if advisory['url']
      advice << "Consider finding alternative gems if no patch is available."
      
      advice.join('. ')
    end

    # Check for insecure Devise configurations
    def check_insecure_devise_configuration
      vulnerabilities = []
      devise_config = project_root.join('config/initializers/devise.rb')
      
      if devise_config.exist?
        content = devise_config.read
        
        # Check for weak password requirements
        if content.match?(/config\.password_length\s*=.*\.\.[0-7]/)
          vulnerabilities << {
            type: 'weak_password_policy',
            severity: 'high',
            message: 'Devise password minimum length is too weak (less than 8 characters)',
            file: 'config/initializers/devise.rb',
            remediation_advice: 'Set config.password_length to at least 8..128 for secure passwords'
          }
        end
        
        # Check for insecure session configuration
        if content.include?('config.timeout_in') && !content.match?(/config\.timeout_in\s*=.*\d+\.minutes/)
          vulnerabilities << {
            type: 'session_timeout',
            severity: 'medium',
            message: 'No session timeout configured in Devise',
            file: 'config/initializers/devise.rb',
            remediation_advice: 'Configure config.timeout_in to automatically expire user sessions'
          }
        end
        
        # Check for insecure remember_me configuration
        if content.match?(/config\.remember_for\s*=.*[^0-9]([5-9]|[1-9][0-9]+)\.weeks/)
          vulnerabilities << {
            type: 'insecure_remember_me',
            severity: 'medium',
            message: 'Devise remember_me duration is too long',
            file: 'config/initializers/devise.rb',
            remediation_advice: 'Limit config.remember_for to 4.weeks or less for better security'
          }
        end
      end
      
      vulnerabilities
    end

    # Check for insecure database configurations
    def check_insecure_database_configuration
      vulnerabilities = []
      database_config = project_root.join('config/database.yml')
      
      if database_config.exist?
        content = database_config.read
        
        # Check for plaintext passwords in production
        if content.match?(/^\s*production:.*\n(?:[^\n]*\n)*?\s*password:\s*[^<][^%]/)
          vulnerabilities << {
            type: 'plaintext_database_password',
            severity: 'critical',
            message: 'Production database password stored in plaintext',
            file: 'config/database.yml',
            remediation_advice: 'Use environment variables for database passwords: password: <%= ENV["DATABASE_PASSWORD"] %>'
          }
        end
        
        # Check for missing SSL configuration
        unless content.include?('sslmode') || content.include?('ssl')
          vulnerabilities << {
            type: 'missing_database_ssl',
            severity: 'high',
            message: 'Database SSL/TLS configuration not found',
            file: 'config/database.yml',
            remediation_advice: 'Configure SSL/TLS for database connections using sslmode: require'
          }
        end
      end
      
      vulnerabilities
    end

    # Check for unsafe agent configurations
    def check_unsafe_agent_configurations
      vulnerabilities = []
      
      # Check JavaScript execution in agents
      agent_files = Dir.glob(project_root.join('app/models/agents/**/*.rb'))
      agent_files.each do |file|
        content = File.read(file)
        
        # Check for unsafe JavaScript evaluation
        if content.include?('eval(') || content.include?('instance_eval(')
          vulnerabilities << {
            type: 'unsafe_code_execution',
            severity: 'critical',
            message: 'Unsafe code execution found in agent',
            file: file.gsub(project_root.to_s + '/', ''),
            remediation_advice: 'Replace eval() with safer alternatives or implement proper sandboxing'
          }
        end
        
        # Check for command injection vulnerabilities
        if content.match?(/system\s*\(.*\$|`.*\$|exec\s*\(.*\$/)
          vulnerabilities << {
            type: 'command_injection_risk',
            severity: 'high',
            message: 'Potential command injection vulnerability in agent',
            file: file.gsub(project_root.to_s + '/', ''),
            remediation_advice: 'Sanitize user input before system calls or use safer alternatives'
          }
        end
      end
      
      vulnerabilities
    end

    # Check security headers configuration
    def check_security_headers_configuration
      warnings = []
      application_config = project_root.join('config/application.rb')
      
      if application_config.exist?
        content = application_config.read
        
        unless content.include?('force_ssl') || content.include?('config.ssl_options')
          warnings << {
            type: 'missing_security_headers',
            severity: 'medium',
            message: 'Security headers configuration not found',
            remediation_advice: 'Configure security headers using config.force_ssl and security header middleware'
          }
        end
      end
      
      warnings
    end

    # Check CSRF protection configuration  
    def check_csrf_protection_configuration
      warnings = []
      application_controller = project_root.join('app/controllers/application_controller.rb')
      
      if application_controller.exist?
        content = application_controller.read
        
        unless content.include?('protect_from_forgery')
          warnings << {
            type: 'missing_csrf_protection',
            severity: 'high',
            message: 'CSRF protection not configured in ApplicationController',
            remediation_advice: 'Add protect_from_forgery with: :exception to ApplicationController'
          }
        end
      end
      
      warnings
    end

    # Check session security configuration
    def check_session_security_configuration
      warnings = []
      session_store = project_root.join('config/initializers/session_store.rb')
      
      if session_store.exist?
        content = session_store.read
        
        unless content.include?('secure: true') || content.include?(':secure => true')
          warnings << {
            type: 'insecure_session_cookies',
            severity: 'medium',
            message: 'Session cookies not configured as secure',
            remediation_advice: 'Configure secure session cookies with secure: true option'
          }
        end
      end
      
      warnings
    end

    # Create a clean scan result with no vulnerabilities
    def create_clean_scan_result(tool_name)
      ScanResult.new(
        passed: true,
        tool: tool_name,
        vulnerabilities: [],
        warnings: [],
        summary: {
          critical_count: 0,
          high_count: 0,
          medium_count: 0,
          low_count: 0
        }
      )
    end

    # Create error result for failed scans
    def create_scan_error_result(tool_name, error_message)
      ScanResult.new(
        passed: false,
        tool: tool_name,
        vulnerabilities: [],
        warnings: [],
        errors: [error_message],
        summary: {
          scan_failed: true,
          error: error_message
        }
      )
    end

    # Combine multiple scan results into comprehensive result
    def combine_scan_results(scan_results_hash)
      all_vulnerabilities = []
      all_warnings = []
      all_errors = []
      
      scan_results_hash.each do |tool_name, scan_result|
        next unless scan_result
        
        all_vulnerabilities.concat(Array(scan_result.vulnerabilities))
        all_warnings.concat(Array(scan_result.warnings))
        all_errors.concat(Array(scan_result.errors)) if scan_result.respond_to?(:errors)
      end
      
      # Determine overall pass/fail based on quality gates
      quality_gate_passed = evaluate_quality_gate_thresholds(all_vulnerabilities)
      
      ScanResult.new(
        passed: quality_gate_passed && all_errors.empty?,
        tool: 'ComprehensiveScan',
        vulnerabilities: all_vulnerabilities,
        warnings: all_warnings,
        errors: all_errors,
        summary: {
          total_vulnerabilities: all_vulnerabilities.size,
          critical_count: all_vulnerabilities.count { |v| v[:severity] == 'critical' },
          high_count: all_vulnerabilities.count { |v| v[:severity] == 'high' },
          medium_count: all_vulnerabilities.count { |v| v[:severity] == 'medium' },
          low_count: all_vulnerabilities.count { |v| v[:severity] == 'low' },
          quality_gate_passed: quality_gate_passed,
          scan_tools: scan_results_hash.keys
        }
      )
    end

    # Evaluate quality gate thresholds
    def evaluate_quality_gate_thresholds(vulnerabilities)
      severity_counts = {
        'critical' => vulnerabilities.count { |v| v[:severity] == 'critical' },
        'high' => vulnerabilities.count { |v| v[:severity] == 'high' },
        'medium' => vulnerabilities.count { |v| v[:severity] == 'medium' },
        'low' => vulnerabilities.count { |v| v[:severity] == 'low' }
      }
      
      quality_gates = config[:quality_gates] || {}
      
      # Zero tolerance for critical and high severity vulnerabilities
      return false if severity_counts['critical'] > 0 && quality_gates.fetch(:fail_on_critical, true)
      return false if severity_counts['high'] > 0 && quality_gates.fetch(:fail_on_high, true)
      
      # Check medium and low severity thresholds
      return false if severity_counts['medium'] > quality_gates.fetch(:max_medium_vulnerabilities, 5)
      return false if severity_counts['low'] > quality_gates.fetch(:max_low_vulnerabilities, 10)
      
      true
    end

    # Log operation start with security context
    def log_operation_start(operation, context = {})
      logger.info("🛡️  Starting: #{operation}")
      context.each { |key, value| logger.info("   #{key}: #{value}") } if context.any?
    end

    # Log operation step
    def log_operation_step(step)
      logger.info("🔍 Step: #{step}")
    end

    # Log operation completion with results
    def log_operation_completion(operation, start_time, result)
      duration = ((Time.current - start_time) * 1000).round(2)
      status = result.passed? ? '✅ PASSED' : '❌ FAILED'
      logger.info("🏁 Completed: #{operation} in #{duration}ms - #{status}")
      
      if result.respond_to?(:errors) && result.errors&.any?
        result.errors.each { |error| logger.error("💥 Error: #{error}") }
      end
    end

    # Log security scan summary
    def log_security_scan_summary(tool_name, result)
      status = result.passed? ? '✅' : '⚠️'
      vuln_count = result.vulnerabilities&.size || 0
      logger.info("#{status} #{tool_name}: #{vuln_count} vulnerabilities found")
      
      if result.respond_to?(:summary) && result.summary
        summary = result.summary
        %w[critical high medium low].each do |severity|
          count = summary[:"#{severity}_count"] || 0
          logger.info("   #{severity.upcase}: #{count}") if count > 0
        end
      end
    end

    # Log security error
    def log_security_error(context, error_message)
      logger.error("🚨 Security Error [#{context}]: #{error_message}")
    end

    # Log security warning
    def log_security_warning(warning_message)
      logger.warn("⚠️  Security Warning: #{warning_message}")
    end

    # Additional methods for comprehensive reporting would continue here...
    # (truncated for length - would include methods for compliance validation,
    # detailed reporting, remediation planning, etc.)
  end

  # Data structure for security scan results
  class ScanResult
    attr_reader :passed, :tool, :vulnerabilities, :warnings, :errors, :summary

    def initialize(passed:, tool:, vulnerabilities: [], warnings: [], errors: [], summary: {})
      @passed = passed
      @tool = tool
      @vulnerabilities = Array(vulnerabilities)
      @warnings = Array(warnings)
      @errors = Array(errors)
      @summary = summary || {}
    end

    def passed?
      @passed
    end

    def failed?
      !@passed
    end

    def has_vulnerabilities?
      @vulnerabilities.any?
    end

    def has_warnings?
      @warnings.any?
    end

    def has_errors?
      @errors.any?
    end

    def critical_vulnerabilities
      @vulnerabilities.select { |v| v[:severity] == 'critical' }
    end

    def high_vulnerabilities  
      @vulnerabilities.select { |v| v[:severity] == 'high' }
    end

    def medium_vulnerabilities
      @vulnerabilities.select { |v| v[:severity] == 'medium' }
    end

    def low_vulnerabilities
      @vulnerabilities.select { |v| v[:severity] == 'low' }
    end
  end

  # Custom exception for security validation errors
  class SecurityValidationError < StandardError; end
end